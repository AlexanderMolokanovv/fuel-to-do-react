
Файл: ./server/combined.log
{"level":"info","message":"fuelComponents.json loaded successfully, length:","timestamp":"2025-08-24T07:55:53.231Z"}
{"level":"info","message":"Server running on port 3001","timestamp":"2025-08-24T07:55:53.240Z"}


Файл: ./server/controllers/calculateController.js
const { calculateFuelEfficiency } = require("../utils/calculations");

exports.calculate = async (req, res) => {
  try {
    const data = req.body;
    const result = await calculateFuelEfficiency(data);
    res.json(result);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

Файл: ./server/C:Usersamolodevfuel-to-do-reactservercombined.log


Файл: ./server/C:Usersamolodevfuel-to-do-reactservererror.log


Файл: ./server/error.log


Файл: ./server/logger.js
const winston = require('winston');
const path = require('path');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: path.join(__dirname, 'error.log'), level: 'error' }),
    new winston.transports.File({ filename: path.join(__dirname, 'combined.log') }),
    new winston.transports.Console({ format: winston.format.simple() })
  ]
});

module.exports = logger;

Файл: ./server/middleware/validateInput.js
const logger = require('../logger');

module.exports = (req, res, next) => {
  logger.info("ValidateInput received request:", JSON.stringify(req.body, null, 2));
  console.log("ValidateInput received request:", JSON.stringify(req.body, null, 2));
  const { vehicleType, engineType, aircraftMass } = req.body;
  if (vehicleType == null || engineType == null || aircraftMass == null) {
    logger.error("Validation failed - Request body:", JSON.stringify(req.body, null, 2));
    console.error("Validation failed - Request body:", JSON.stringify(req.body, null, 2));
    return res.status(400).json({ error: "Missing required fields" });
  }
  logger.info("Validation passed - Request body:", JSON.stringify(req.body, null, 2));
  console.log("Validation passed - Request body:", JSON.stringify(req.body, null, 2));
  next();
};

Файл: ./server/routes/calculateRoutes.js
const express = require("express");
const router = express.Router();
const calculateController = require("../controllers/calculateController");
const validateInput = require("../middleware/validateInput");

router.post("/calculate", validateInput, calculateController.calculate);

module.exports = router;


Файл: ./server/server.js
const express = require("express");
const cors = require("cors");
const calculateRoutes = require("./routes/calculateRoutes");
const logger = require("./logger");

const app = express();

app.use(cors());
app.use(express.json());

app.use("/api", calculateRoutes);

module.exports = app;

if (require.main === module) {
  const PORT = process.env.PORT || 3001;
  app.listen(PORT, () => logger.info(`Server running on port ${PORT}`));
}

Файл: ./server/tests/calculate.test.js
const request = require("supertest");
const app = require("../server");

describe("POST /api/calculate", () => {
  let server;

  beforeAll((done) => {
    server = app.listen(0, () => done());
  });

  afterAll((done) => {
    server.close(() => done());
  });

  it("should return calculation results", async () => {
    const response = await request(app)
      .post("/api/calculate")
      .send({
        vehicleType: "airplane",
        engineType: "gasturbine",
        aircraftMass: 1000,
        fuelTankVolume: 1000,
        payload: 1000,
        wsmCoefficients: {
          range: 50,
          payload: 50,
          ecology: 50,
          cost: 50,
          reliability: 50
        },
        limitingParameters: {
          freezingTemp: { min: -100, max: -20 },
          density: { min: 600, max: 1000 },
          viscosity: { min: 0.1, max: 10 },
          combustionHeat: { min: 15000, max: 50000 },
          coolingResource: { min: 1000, max: 3000 },
          thermalConductivity: { min: 0.05, max: 0.3 },
          heatCapacity: { min: 1000, max: 5000 },
          inductionPeriod: { min: 200, max: 800 },
          burningRate: { min: 0.05, max: 2 },
          vaporPressure: { min: 0.1, max: 100 }
        }
      })
      .expect(200);
    expect(response.body).toHaveProperty("fuelEfficiency");
  });
});

Файл: ./server/utils/calculations.js
const logger = require('../logger');
const path = require('path');

let fuelComponents;
try {
  fuelComponents = require(path.join(__dirname, '../data/fuelComponents.json'));
  logger.info("fuelComponents.json loaded successfully, length:", fuelComponents.length);
  console.log("fuelComponents.json loaded successfully, length:", fuelComponents.length);
} catch (error) {
  logger.error("Failed to load fuelComponents.json:", error.message);
  console.error("Failed to load fuelComponents.json:", error.message);
  fuelComponents = [];
}

exports.calculateFuelEfficiency = async (data) => {
  logger.info("Received data in calculations.js:", JSON.stringify(data, null, 2));
  console.log("Received data in calculations.js:", JSON.stringify(data, null, 2));
  const { vehicleType, engineType, aircraftMass, fuelTankVolume, payload, wsmCoefficients, limitingParameters } = data;

  logger.info("Loaded fuelComponents length:", fuelComponents.length);
  console.log("Loaded fuelComponents length:", fuelComponents.length);
  logger.info("First component example:", fuelComponents[0] ? JSON.stringify(fuelComponents[0].compatibleWith) : 'No components loaded');
  console.log("First component example:", fuelComponents[0] ? JSON.stringify(fuelComponents[0].compatibleWith) : 'No components loaded');

  logger.info("Input types:", { vehicleType: typeof vehicleType, engineType: typeof engineType });
  console.log("Input types:", { vehicleType: typeof vehicleType, engineType: typeof engineType });

  const components = fuelComponents.filter(c => c.compatibleWith.includes(vehicleType) && c.compatibleWith.includes(engineType));
  logger.info("Filtered component names:", components.map(c => c.name));
  console.log("Filtered component names:", components.map(c => c.name));

  if (!components.length) {
    logger.error(`No compatible components for vehicleType: ${vehicleType}, engineType: ${engineType}`);
    console.error(`No compatible components for vehicleType: ${vehicleType}, engineType: ${engineType}`);
    throw new Error('No compatible fuel components found');
  }

  const totalComponents = Math.min(components.length, 6);
  const proportions = [0.50, 0.20, 0.15, 0.10, 0.03, 0.02].slice(0, totalComponents);
  const sumProportions = proportions.reduce((sum, p) => sum + p, 0);
  const normalizedProportions = proportions.map(p => p / sumProportions);
  const mixture = components.slice(0, totalComponents).map((component, index) => ({
    name: component.name,
    proportion: normalizedProportions[index] || 0
  }));
  logger.info("Selected mixture:", JSON.stringify(mixture, null, 2));
  console.log("Selected mixture:", JSON.stringify(mixture, null, 2));

  const properties = {
    freezingTemp: 0,
    density: 0,
    viscosity: 0,
    combustionHeat: 0,
    coolingResource: 0,
    thermalConductivity: 0,
    heatCapacity: 0,
    inductionPeriod: 0,
    burningRate: 0,
    vaporPressure: 0
  };
  Object.keys(properties).forEach(prop => {
    properties[prop] = mixture.reduce((sum, m) => {
      const comp = components.find(c => c.name === m.name);
      return sum + (comp ? m.proportion * comp[prop] : 0);
    }, 0);
    logger.info(`Calculated ${prop}: ${properties[prop]}`);
    console.log(`Calculated ${prop}: ${properties[prop]}`);
  });

  let valid = true;
  const failedProperties = [];
  Object.keys(limitingParameters).forEach(key => {
    const { min, max } = limitingParameters[key];
    if (isNaN(min) || isNaN(max)) {
      logger.error(`Invalid min/max for ${key}: min=${min}, max=${max}`);
      console.error(`Invalid min/max for ${key}: min=${min}, max=${max}`);
      valid = false;
    } else if (min === max && min === 0) {
      return;
    } else if (properties[key] < min || properties[key] > max) {
      logger.error(`Property ${key} (${properties[key]}) outside range [${min}, ${max}]`);
      console.error(`Property ${key} (${properties[key]}) outside range [${min}, ${max}]`);
      failedProperties.push({ key, value: properties[key], min, max });
      valid = false;
    }
  });
  if (!valid) {
    logger.error("Failed properties:", JSON.stringify(failedProperties, null, 2));
    console.error("Failed properties:", JSON.stringify(failedProperties, null, 2));
    throw new Error('No valid mixture found');
  }

  const energyDensity = properties.combustionHeat / properties.density;
  const fuelEfficiency = 0.85 + (wsmCoefficients.range / 100) * 0.15;
  const maxRange = (energyDensity * fuelTankVolume / aircraftMass) * 0.5;
  const cost = payload * 1000 * properties.density;

  const viscosityTemps = [-20, -10, 0, 10, 20, 30];
  const viscosityData = viscosityTemps.map(temp => {
    const dataPoint = { temp };
    mixture.forEach((comp, i) => {
      const component = fuelComponents.find(c => c.name === comp.name);
      if (component) {
        const viscosity = component.viscosity * (1 - 0.02 * (temp + 20) / 10);
        dataPoint[`sample${i + 1}`] = Number(viscosity.toFixed(2));
      }
    });
    return dataPoint;
  });

  const heatCapacityPoints = [1, 2, 3, 4, 5, 6];
  const heatCapacityData = heatCapacityPoints.map(point => {
    const dataPoint = { temp: point * 100 };
    mixture.forEach((comp, i) => {
      const component = fuelComponents.find(c => c.name === comp.name);
      if (component) {
        const variation = 1 + (Math.random() - 0.5) * 0.1;
        dataPoint[`sample${i + 1}`] = Number((component.heatCapacity * variation / 1000).toFixed(2));
      }
    });
    return dataPoint;
  });

  return {
    mixture,
    properties,
    fuelEfficiency,
    maxRange,
    cost,
    graphData: {
      viscosity: viscosityData,
      heatCapacity: heatCapacityData
    }
  };
};
